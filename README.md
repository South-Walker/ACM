# ACM
for algorithm
<br>3-3<br> 这几天忙着做大创网页<a href="https://github.com/South-Walker/dachuang" target="_blank" title="dachuang">@South-Walker/dachuang</a>所以算法方面的代码量少了，2月28之前的都是数据结构的学习记录，本人不打算参加ACM竞赛只是想学习算法方面的思想， 故语言上选择的是较为顺手的C#，今天的内容是吊死鬼游戏与发救济金，意识到了删除数据（节点）可以顺手做一个标记，或赋值0，可以省去后面判断的很多麻烦，在发救 济金中用到了双向循环链表，感觉是小题大做，明显没有答案用数组的简单。

<br>3-5<br> 
忙着做大创问卷录入，很惭愧的一星期，今天这道信息解码题做复杂了，可能是刚学完数据结构的原因，做了两个队列结果什么也没做出来，明明只是需要一个二元数字的事情，惭愧

<br>3-6<br>
725,11059应该是两道水题，从看题到有思路没有超过10分钟，值得学习的是725中标准答案的判断两个数是否有0~9的方法
我采用的是拼接字符串的方法，然后2个for循环嵌套检查是否充足重复数字。答案则是构造了数字，出现对应数字时，数组对应项值为1，
最后做sum判断是否是10。答案的方法简单明了，在于对任意2个数字就执行10次数组赋值，而我的方法一是要考虑存在0的情况多于答案二是
2层for循环代表我可能要执行100次才能判断正确与否，小处见真知，一直以来的工作都是在忙于实现，看似熟悉了工具，到了比拼算法的时候
不足就暴露出来了，惭愧惭愧。
11059怎么说呢，先反思一下自己数量级估计错误，用int导致溢出吧，然后自己明显是用一个复杂的方法去解决了一个很简单的问题
虽然就效率而言可能是我的算法比较快，但是用最简单的穷举也能保证在规定时间内完成，见仁见智吧。

<br>3-7<br>
10976,简单题，立即想到了枚举范围是K到2K以及需要对等式变形，美中不足是变形的不彻底导致了必须引入double类型代替int类型，
答案变形成了y * k % (y-k) == 0即y*k恰是y-k的x倍，总之算差强人意的完成了
<br>p.s. 今天遇到一个很难调试的bug，原理是这样的 C#中类、接口、数组和字符串被称为引用类型，变量储存的是其在内存中的地址，
故会出现
<br>int[] array = {1,2};
int[] temp = array;
temp[0] = 0;
console.write(array[0]);//输出0
<br>记之

<br>3-10<br>
524,乍看很难的一题，但是想清楚后发现可以很简单的递归实现，只是需要记得在递归结束后需要将数据还原，昨天书里的内容，感觉刷了这么多天题下来自己真的有变强。继续努力

<br>3-11<br>
129,看见题目人先傻掉了，英语能力有待提高，然后是理解题意后发现应该是简单题，加之前无重复，加之后重复，那重复的一个子集中一定包括末尾。
进一步分析，如果因为加入最后一个产生重复，那么最差的情况下重复的每个子集之和为全部集合，即各占一半。那么最多要查K/2次确定1个字母能否放入
最差需要判断L次才能知道下一个字母，乘法原理，LK^2次计算可得解，无论如何都不可能超时！
另外记一个网页http://www.uvatoolkit.com/problemssolve.php 既然无法在vjac那就自己拿数据自己帮自己ac

<br>3-12<br>
140,可能是这么多天最难的一题了？先是题目难以理解，理解之后思路首先是做递归全排列，因为只有8位，故可以o（n^2）。然后计算带宽是最难的部分
剪枝，还只是其次，因为用了二元数组表连接，差点被字母和数字之间的互换搞糊涂，然后是因为数组是引用类型，所以必须以字符串的形式
保存当前最小的带宽对应的次序，真的累。
<br>
1354，崩溃。。。。看了答案用了二叉，还没学到，下一周补上吧。

总结：剪枝与回溯都是在函数递归中为减少计算量而使用的方法，使用前要仔细思考是否多剪，是否少回。
p.s.uva140的代码写太丑了！！要减少全局变量的使用。
<br>
<br>3-13<br>
题目超级。。简单，可能是为了熟悉c++特性的，没什么好讲，特别的是今天做大创的后台数据提取也用到的算法思维，题目是这样的：
<br>肖某在一个星期前在网上发布了一副调查问卷，一个星期来一共收集了501张问卷，其中，问卷有多选，单项，简答三种题型
其中，为图存储方便，肖某录入数据库的形式是这样的，如果问题是简答，那么以字符串的形式存储，如果问题是多选，单选，则按
A=1，B=2，C=4，D=8，E=16......（选项最多有11个即H=1024）的方式，将回答做加和，以加和的形式存入。一个星期后，肖某需要
提取这些数字继续问卷分析，其中，最复杂的的分析是这样的。
<br>输入<br><br>
2
A,B,D
4
<br>输出<br>
<br>
一个一元数组（由数组画出表格的程序已经写好），横坐标表示第四题的所有选项，纵坐标表示选择该选项，且在第二题同时选择了A,B,D选项（包括选择A,B,C,D的人，但是显然不包括选择B,D的人）
对应的人数。
<br>
<br>
ok,搞定，思路如下：<br>
以输入为例，定义2为依赖项，构造一元bool数组，递归法把数组中第0,1,3标示为true，（先判断回答是否大于1024，若是，第11项
为true，然后减去1024。之后，再判断是否大于512，若是，第10项为true，然后减去512......至答案值为0）得到一个表示所选选项的
数组，同理，对第四题构造同样数组，循环判断：如果存在int i 满足对2的bool[i] == true，对4的bool[i] == false，则该条舍弃，
否则入栈执行和之前所写的普通查询一样的程序。<a href="http://xiaoliming96.com/RelatedSelect.aspx" target="_blank" title="dachuang">应用该算法的页面</a>
<br>
<br>3-14<br>
101,看得不是特别明白，大致上好像是要自己实现一个栈的结构（题目里多次出现stack），支持特定的增删改查操作（vector in c++ == arraylist in c#？），显然的，每一个栈中，如果存在木块，第一个木块序号肯定是当前栈的序号。
因为没有任何方法能在不指定上一块木块的情况下，将任意木块移动到任意位置，讲道理代码复用率太高，肯定要重构写成方法去优化的
但是。。没必要。。。算了吧，还有大创要做
<br>3-15<br>
10815,题外话，刚刚才发现昨天题目日期写了3-15..今天的题目改成true3-15好了。安迪的字典，显然的二叉添加与查询，显然的中序遍历
拿来练手正好，自己实现了一个普通的二叉树。。（自己写的比书上写的丑太多了。。）性能优化方面可以试试看avl平衡二叉，不过没有这个必要
暂时就算了吧，有点羡慕C++啊。