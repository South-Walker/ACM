# ACM
for algorithm
<br>3-3<br> 这几天忙着做大创网页<a href="https://github.com/South-Walker/dachuang" target="_blank" title="dachuang">@South-Walker/dachuang</a>所以算法方面的代码量少了，2月28之前的都是数据结构的学习记录，本人不打算参加ACM竞赛只是想学习算法方面的思想， 故语言上选择的是较为顺手的C#，今天的内容是吊死鬼游戏与发救济金，意识到了删除数据（节点）可以顺手做一个标记，或赋值0，可以省去后面判断的很多麻烦，在发救 济金中用到了双向循环链表，感觉是小题大做，明显没有答案用数组的简单。

<br>3-5<br> 
忙着做大创问卷录入，很惭愧的一星期，今天这道信息解码题做复杂了，可能是刚学完数据结构的原因，做了两个队列结果什么也没做出来，明明只是需要一个二元数字的事情，惭愧

<br>3-6<br>
725,11059应该是两道水题，从看题到有思路没有超过10分钟，值得学习的是725中标准答案的判断两个数是否有0~9的方法
我采用的是拼接字符串的方法，然后2个for循环嵌套检查是否充足重复数字。答案则是构造了数字，出现对应数字时，数组对应项值为1，
最后做sum判断是否是10。答案的方法简单明了，在于对任意2个数字就执行10次数组赋值，而我的方法一是要考虑存在0的情况多于答案二是
2层for循环代表我可能要执行100次才能判断正确与否，小处见真知，一直以来的工作都是在忙于实现，看似熟悉了工具，到了比拼算法的时候
不足就暴露出来了，惭愧惭愧。
11059怎么说呢，先反思一下自己数量级估计错误，用int导致溢出吧，然后自己明显是用一个复杂的方法去解决了一个很简单的问题
虽然就效率而言可能是我的算法比较快，但是用最简单的穷举也能保证在规定时间内完成，见仁见智吧。

<br>3-7<br>
10976,简单题，立即想到了枚举范围是K到2K以及需要对等式变形，美中不足是变形的不彻底导致了必须引入double类型代替int类型，
答案变形成了y * k % (y-k) == 0即y*k恰是y-k的x倍，总之算差强人意的完成了
<br>p.s. 今天遇到一个很难调试的bug，原理是这样的 C#中类、接口、数组和字符串被称为引用类型，变量储存的是其在内存中的地址，
故会出现
<br>int[] array = {1,2};
int[] temp = array;
temp[0] = 0;
console.write(array[0]);//输出0
<br>记之

<br>3-10<br>
524,乍看很难的一题，但是想清楚后发现可以很简单的递归实现，只是需要记得在递归结束后需要将数据还原，昨天书里的内容，感觉刷了这么多天题下来自己真的有变强。继续努力

<br>3-11<br>
129,看见题目人先傻掉了，英语能力有待提高，然后是理解题意后发现应该是简单题，加之前无重复，加之后重复，那重复的一个子集中一定包括末尾。
进一步分析，如果因为加入最后一个产生重复，那么最差的情况下重复的每个子集之和为全部集合，即各占一半。那么最多要查K/2次确定1个字母能否放入
最差需要判断L次才能知道下一个字母，乘法原理，LK^2次计算可得解，无论如何都不可能超时！
另外记一个网页http://www.uvatoolkit.com/problemssolve.php 既然无法在vjac那就自己拿数据自己帮自己ac

<br>3-12<br>
140,可能是这么多天最难的一题了？先是题目难以理解，理解之后思路首先是做递归全排列，因为只有8位，故可以o（n^2）。然后计算带宽是最难的部分
剪枝，还只是其次，因为用了二元数组表连接，差点被字母和数字之间的互换搞糊涂，然后是因为数组是引用类型，所以必须以字符串的形式
保存当前最小的带宽对应的次序，真的累。
<br>
1354，崩溃。。。。看了答案用了二叉，还没学到，下一周补上吧。

总结：剪枝与回溯都是在函数递归中为减少计算量而使用的方法，使用前要仔细思考是否多剪，是否少回。
p.s.uva140的代码写太丑了！！要减少全局变量的使用。
<br>
<br>3-13<br>
题目超级。。简单，可能是为了熟悉c++特性的，没什么好讲，特别的是今天做大创的后台数据提取也用到的算法思维，题目是这样的：
<br>肖某在一个星期前在网上发布了一副调查问卷，一个星期来一共收集了501张问卷，其中，问卷有多选，单项，简答三种题型
其中，为图存储方便，肖某录入数据库的形式是这样的，如果问题是简答，那么以字符串的形式存储，如果问题是多选，单选，则按
A=1，B=2，C=4，D=8，E=16......（选项最多有11个即H=1024）的方式，将回答做加和，以加和的形式存入。一个星期后，肖某需要
提取这些数字继续问卷分析，其中，最复杂的的分析是这样的。
<br>输入<br><br>
2
A,B,D
4
<br>输出<br>
<br>
一个一元数组（由数组画出表格的程序已经写好），横坐标表示第四题的所有选项，纵坐标表示选择该选项，且在第二题同时选择了A,B,D选项（包括选择A,B,C,D的人，但是显然不包括选择B,D的人）
对应的人数。
<br>
<br>
ok,搞定，思路如下：<br>
以输入为例，定义2为依赖项，构造一元bool数组，递归法把数组中第0,1,3标示为true，（先判断回答是否大于1024，若是，第11项
为true，然后减去1024。之后，再判断是否大于512，若是，第10项为true，然后减去512......至答案值为0）得到一个表示所选选项的
数组，同理，对第四题构造同样数组，循环判断：如果存在int i 满足对2的bool[i] == true，对4的bool[i] == false，则该条舍弃，
否则入栈执行和之前所写的普通查询一样的程序。<a href="http://xiaoliming96.com/RelatedSelect.aspx" target="_blank" title="dachuang">应用该算法的页面</a>
<br>
<br>3-14<br>
101,看得不是特别明白，大致上好像是要自己实现一个栈的结构（题目里多次出现stack），支持特定的增删改查操作（vector in c++ == arraylist in c#？），显然的，每一个栈中，如果存在木块，第一个木块序号肯定是当前栈的序号。
因为没有任何方法能在不指定上一块木块的情况下，将任意木块移动到任意位置，讲道理代码复用率太高，肯定要重构写成方法去优化的
但是。。没必要。。。算了吧，还有大创要做
<br>3-15<br>
10815,题外话，刚刚才发现昨天题目日期写了3-15..今天的题目改成true3-15好了。安迪的字典，显然的二叉添加与查询，显然的中序遍历
拿来练手正好，自己实现了一个普通的二叉树。。（自己写的比书上写的丑太多了。。）性能优化方面可以试试看avl平衡二叉，不过没有这个必要
暂时就算了吧，有点羡慕C++啊，一个set什么都搞定了。
<br>uva1354,今天弄明白了解答是如何穷举及如何存放穷举的，运用了二叉的思想，但是没有用二叉的结构，
第一次见识到，运用数组表示二叉的方法，i项-1表示节点，2i及2i+1对应节点上的两子节点，递归考虑也是很周全，回溯回来必须将数据
返回原来的值就不说了，每一个if判断的剪枝位置也是正好。。。。真是羡慕啊
<br>3-16<br>
<br>uva156我不记得了，反正是简单题，但是当我用冒泡去排序的时候我知道我输了，虽然复杂度应该还是o(n^2)这个量级，但是毕竟是慢了好多<br>
今天应该能够把uva1354终结了，归并排序和快速排序也可以提上日程了。已经终结。
<br>3-18<br>
<br>uva12096血崩，得几个教训总结一下吧，一个是现在的能力不能随意的使用结构的嵌套，原因有2，一是结构体大多为引用类型，二是结构体的嵌套无法递归
比较大小（如今水平）如果说uva1354是从逻辑上把人打死，那12096就是从语言特性上堵住了路，很难受
<br>debug笔记<br>
        static public void Cadd()
        {
            ArrayList al_1 = (ArrayList)stack_main.Pop();
            ArrayList al_2 = (ArrayList)stack_main.Pop();
            al_2.Add(al_1);
            stack_main.Push(al_2);
            Console.WriteLine(((ArrayList)stack_main.Peek()).Count);
        }
<br>这个代码的错误在 al_1 == al_2 的时候，它把一个盒子放到了自己里面（al_2存储了一个指向al_2本身的指针）
<br>
uva540。。。。。，难度梯度要不要这么大啊，简单题，要求常数级别的复杂度，问题出在入队的时候，即不能通过遍历队列来插队，那就空间换时间咯
哈希表存组，main队列存储组数，各组集合构成一个队列数组，在其中存储元素，出队入队都是常数级，完美。
<br>uva136。。。。我居然。。不会做。。。看了书，使用了优先队列，c#里没有内置，在百度上抄了别人实现的代码解决了，这个真的叫阴沟里翻船。。

<br>p.s.今天fork了一份归并排序的算法，算是对分治法的复习，离完全脱离资料写出来还有点距离，还需要复习与在实践中熟悉

<br>3-19<br>模拟题，第一题不用编程，1806没什么毛病，第二题 40096，没毛病，直接输出应该也不用考虑复杂度，第三题，什么鬼。。
考虑如下数组{ "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a" }
0 = {16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0}
1 = {16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,0,1}
2 = {16,15,14,13,12,11,10,9,8,7,6,5,4,3,1,2,0}
3 = {16,15,14,13,12,11,10,9,8,7,6,5,4,3,1,0,2}
4 = {16,15,14,13,12,11,10,9,8,7,6,5,4,3,0,2,1}

aim = {15,14,6,11,0,5,16,7,9,12,4,10,8,2,13,3,1}
<br>总结出如下规律<br>1.所有字母不重复，且全部出现一次<br>2.从左至右一个个比较，较大的数字一定先小于较小的数字。
<br>

<br>第四题，java版本，初步猜测应该是return (t / (Math.Abs(t))) * (Math.Abs(t) + 1);（其实我不会java，这个是c#）
确实是对的
<br>第五题，1秒时间，计算机每秒千万级运算，假设年利率30%，6月还完，换成分差不多是191666，就算我傻乎乎从1算到20w也不可能超过1s，怎么想都可以暴力,
<br>剩下第三第四第五，复习归并排序，学习快速排序，先休息一下（可能要休息一天）<br>第五题想错了，因为最多有24个月，每个月都算其实是很危险的
需要类似剪枝的操作，拿当前枚举的数乘以月数，小于1W的可以排除，大于2W的同理